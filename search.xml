<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文转自：https://juejin.im/post/5dcbb828f265da4cf85d84b4写在前面第1题 谈谈变量提升？参考解析参考解析第2题 说说bind、call、apply的 区别？参考解析参考解析第3题 如何实现一个 bind 函数？参考解析参考解析第4题 请实现一个 call 函数参考解析参考解析第5题 如何实现一个 apply 函数？参考解析参考解析第6题 简单说下原型链？参考解析参考解析第7题 怎么判断对象类型？参考解析参考解析第8题 说说箭头函数的特点参考解析参考解析第9题 如何确定This指向参考解析参考解析第10题 async、await 的优缺点参考解析参考解析第11题 generator 原理参考解析参考解析第12题 对Promise的理解参考解析参考解析第13题 == 和 ===区别，什么情况用 ==参考解析参考解析第14题 垃圾回收 新生代算法，老生代算法参考解析参考解析第15题 说说你对闭包的理解参考解析参考解析第16题 基本数据类型和引⽤类型在存储上的差别参考解析参考解析第17题 浏览器 Eventloop 和 Node 中的有什么区别参考解析参考解析第18题 怎样理解setTimeout 执行误差参考解析参考解析第19题 说说函数节流和防抖参考解析参考解析第20题 数组降维参考解析参考解析第21题 请实现一个深拷贝参考解析参考解析第22题 typeof 于 instanceof 区别参考解析参考解析第23题 cookie和localSrorage、session、indexDB 的区别参考解析参考解析第24题 怎么判断页面是否加载完成？参考解析参考解析第25题 说说 jsonp 原理参考解析参考解析第26题 说说你对Service worker的理解参考解析参考解析第27题 说说浏览器缓存机制参考解析参考解析第28题 怎样选择合适的缓存策略参考解析参考解析第29题 说说重绘（Repaint）和回流（Reflow）参考解析参考解析第30题 如何优化图片参考解析参考解析第31题 页面首屏渲染性能优化方案有哪些参考解析参考解析第32题 浏览器性能问题-使用 Webpack 优化项目参考解析参考解析第33题 Babel 原理参考解析参考解析第34题 介绍下React 生命周期参考解析参考解析第35题 react setState 机制参考解析参考解析第36题 Vue的 nextTick 原理参考解析参考解析第37题 Vue 生命周期参考解析参考解析第38题 Vue 双向绑定参考解析参考解析第39题 v-model原理参考解析参考解析第40题 watch 和 computed 的区别和运用的场景参考解析参考解析第41题 Vue 的父子通信参考解析参考解析第42题 简述路由原理参考解析参考解析第43题 MVVM-脏数据检测参考解析参考解析第44题 MVVM-数据劫持参考解析参考解析第45题 React V16 生命周期函数用法参考解析参考解析第46题 Vue 和 React 区别参考解析参考解析第47题 介绍下虚拟 DOM，对虚拟 DOM 的理解参考解析参考解析第48题 路由鉴权参考解析参考解析第49题 TCP 3次握手参考解析参考解析第50题 TCP 拥塞控制参考解析参考解析第51题 慢开始算法参考解析参考解析第52题 拥塞避免算法参考解析参考解析第53题 tcp 快速重传参考解析参考解析第54题 TCP New Ren 改进后的快恢复参考解析参考解析第55题 HTTPS 握手参考解析参考解析第56题 从输入 URL 到页面加载全过程参考解析参考解析第57题 HTTP 常用状态码 301 302 304 403参考解析参考解析第58题 常见排序-冒泡排序参考解析参考解析第59题 常见排序-插入排序参考解析参考解析第60题 常见排序-选择排序参考解析参考解析第61题 常见排序-归并排序参考解析参考解析第62题 常见排序-快排参考解析参考解析第63题 常见排序-堆排序参考解析参考解析第64题 常见排序-系统自带排序实现参考解析参考解析第65题 介绍下设计模式-工厂模式参考解析参考解析第66题 介绍下设计模式-单例模式参考解析参考解析第67题 介绍下设计模式-适配器模式参考解析参考解析第68题 介绍下设计模式-装饰模式参考解析参考解析第69题 介绍下设计模式-代理模式参考解析参考解析第70题 介绍下设计模式-发布-订阅模式参考解析参考解析第71题 Vue 响应式原理参考解析参考解析第72题 实现一个new操作符参考解析参考解析第73题 实现一个JSON.stringify参考解析参考解析第74题 实现一个JSON.parse参考解析参考解析第75题 手写一个继承参考解析参考解析第76题 实现一个JS函数柯里化参考解析参考解析第77题 请手写一个Promise(中高级必考)参考解析参考解析第78题 手写防抖(Debouncing)和节流(Throttling)参考解析参考解析第79题 实现一个instanceOf参考解析参考解析第80题 实现一个私有变量参考解析参考解析第81题 使用setTimeout代替setInterval进行间歇调用参考解析参考解析第82题 数组中的forEach和map的区别参考解析参考解析第83题 for in和for of的区别参考解析参考解析第84题 写一个发布订阅 EventEmitter方法参考解析参考解析第85题 let、var、const区别参考解析参考解析第86题 typeof和instanceof 区别参考解析参考解析第87题 常见的继承的几种方法参考解析参考解析第88题 常见的浏览器内核有哪些?参考解析参考解析第89题 浏览器的主要组成部分是什么？参考解析参考解析第90题 浏览器是如何渲染UI的？参考解析参考解析第91题 浏览器如何解析css选择器？参考解析参考解析第92题 DOM Tree是如何构建的？参考解析参考解析第93题 重绘与重排的区别？参考解析参考解析第94题 如何触发重排和重绘？参考解析参考解析第95题 如何避免重绘或者重排？参考解析参考解析第96题 前端如何实现即时通讯？参考解析参考解析第97题 什么是浏览器同源策略？参考解析参考解析第98题 怎样解决跨域问题？参考解析参考解析第99题 时间格式化参考解析参考解析第100题 说说对html 语义化的理解参考解析参考解析第101题 说说常用的 meta 标签参考解析参考解析第102题 说说两种盒模型以及区别参考解析参考解析第103题 css reset 和 normalize.css 有什么区别参考解析参考解析第104题 怎样让元素水平垂直居中参考解析参考解析第105题 说说选择器的权重计算方式参考解析参考解析第106题 清除浮动的方法参考解析参考解析第107题 说说你对 BFC 的理解参考解析参考解析第108题 import 和 link 区别参考解析参考解析第109题 说下 [1, 2, 3].map(parseInt) 结果参考解析参考解析第110题 介绍下浏览器事件委托参考解析参考解析第111题 10w 条记录的数组，一次性渲染到页面上，如何处理可以不冻结UI？参考解析参考解析第112题 如何实现一个左右固定，中间自适应的三栏布局参考解析参考解析第113题 如何实现一个自适应的正方形参考解析参考解析第114题 如何用css实现一个三角形参考解析参考解析第115题 介绍下 positon 属性参考解析参考解析第116题 说说渐进增强和优雅降级参考解析参考解析第117题 defer和async区别参考解析参考解析第118题 实现sleep函数参考解析参考解析第119题 实现 lazyMan参考解析参考解析第120题 获取元素的最终background-color参考解析参考解析]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试题 - 分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex面试题汇总]]></title>
    <url>%2F2019%2F11%2F16%2FVuex%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Vuex面试题汇总文章转载自： https://juejin.im/post/5dba91e4518825647e4ef18b什么是Vuex？参考答案Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交mutation，例this.$store.commit('SET_VIDEO_PAUSE', video_pause，SET_VIDEO_PAUSE为mutation属性中定义的方法 。Vuex解决了什么问题？参考答案解决两个问题多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。什么时候用Vuex？参考答案当项目遇到以下两种场景时多个组件依赖于同一状态时。来自不同组件的行为需要变更同一状态。Vuex的5个核心属性是什么？参考答案分别是 state、getter、mutation、action、module 。Vuex中状态储存在哪里，怎么改变它？参考答案存储在state中，改变Vuex中的状态的唯一途径就是显式地提交 (commit) mutation。Vuex中状态是对象，使用时候注意什么？参考答案因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。怎么在组件中批量使用Vuex的state状态？参考答案使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中import {mapState} from 'vuex' export default{ computed:{ ...mapState(['price','number']) } } 复制代码Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做，？参考答案使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。const store = new Vuex.Store({ state: { price: 10, number: 10, discount: 0.7, }, getters: { total: state =&gt; { return state.price * state.number }, discountTotal: (state, getters) =&gt; { return state.discount * getters.total } }, }); 复制代码然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。computed: { total() { return this.$store.getters.total }, discountTotal() { return this.$store.getters.discountTotal } } 复制代码怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？参考答案通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { getTodoById: (state) =&gt; (id) =&gt;{ return state.todos.find(todo =&gt; todo.id === id) } }, }); 复制代码然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。computed: { getTodoById() { return this.$store.getters.getTodoById }, } mounted(){ console.log(this.getTodoById(2).done)//false } 复制代码怎么在组件中批量使用Vuex的getter属性参考答案使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中import {mapGetters} from 'vuex' export default{ computed:{ ...mapGetters(['total','discountTotal']) } } 复制代码怎么在组件中批量给Vuex的getter属性取别名并使用参考答案使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中import {mapGetters} from 'vuex' export default{ computed:{ ...mapGetters( myTotal:'total', myDiscountTotal:'discountTotal', ) } } 复制代码在Vuex的state中有个状态number表示货物数量，在组件怎么改变它。参考答案首先要在mutations中注册一个mutationconst store = new Vuex.Store({ state: { number: 10, }, mutations: { SET_NUMBER(state,data){ state.number=data; } }, }); 复制代码在组件中使用this.$store.commit提交mutation，改变numberthis.$store.commit('SET_NUMBER',10) 复制代码在Vuex中使用mutation要注意什么。参考答案mutation 必须是同步函数在组件中多次提交同一个mutation，怎么写使用更方便。参考答案使用mapMutations辅助函数,在组件中这么使用methods:{ ...mapMutations({ setNumber:'SET_NUMBER', }) } 复制代码然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)Vuex中action和mutation有什么区别？参考答案action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。action 可以包含任意异步操作。mutation只能是同步操作。提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。mutation是用this.$store.commit('SET_NUMBER',10)来提交。接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了{ state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中 } 复制代码Vuex中action和mutation有什么相同点？参考答案第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch('ACTION_NAME',data)和this.$store.commit('SET_NUMBER',10)在组件中多次提交同一个action，怎么写使用更方便。参考答案使用mapActions辅助函数,在组件中这么使用methods:{ ...mapActions({ setNumber:'SET_NUMBER', }) } 复制代码然后调用this.setNumber(10)相当调用this.$store.dispatch('SET_NUMBER',10)Vuex中action通常是异步的，那么如何知道action什么时候结束呢？参考答案在action函数中返回Promise，然后再提交时候用then处理actions:{ SET_NUMBER_A({commit},data){ return new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt;{ commit('SET_NUMBER',10) },2000) } ) } } this.$store.dispatch('SET_NUMBER_A').then(() =&gt; { // ... }) 复制代码Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现？参考答案利用ES6的async和await来实现。actions:{ async actionA({commit}){ //... }, async actionB({dispatch}){ await dispatch ('actionA')//等待actionA完成 // ... } } 复制代码有用过Vuex模块吗，为什么要使用，怎么使用。参考答案有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。在module文件新建moduleA.js和moduleB.js文件。在文件中写入const state={ //... } const getters={ //... } const mutations={ //... } const actions={ //... } export default{ state, getters, mutations, actions } 复制代码然后再index.js引入模块import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); import moduleA from './module/moduleA' import moduleB from './module/moduleB' const store = new Vuex.Store({ modules:{ moduleA, moduleB } }) export default store 复制代码在模块中，getter和mutation接收的第一个参数state，是全局的还是模块的？参考答案第一个参数state是模块的state，也就是局部的state。在模块中，getter和mutation和action中怎么访问全局的state和getter？参考答案在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。在mutation中不可以访问全局的satat和getter，只能访问到局部的state。在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？参考答案直接通过this.$store.getters和this.$store.state来访问模块中的getter和state。直接通过this.$store.commit('mutationA',data)提交模块中的mutation。直接通过this.$store.dispatch('actionA,data')提交模块中的action。用过Vuex模块的命名空间吗？为什么使用，怎么使用。参考答案默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action。这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。export default{ namespaced: true, state, getters, mutations, actions } 复制代码怎么在带命名空间的模块内提交全局的mutation和action？参考答案将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。this.$store.dispatch('actionA', null, { root: true }) this.$store.commit('mutationA', null, { root: true }) 复制代码怎么在带命名空间的模块内注册全局的action？参考答案actions: { actionA: { root: true, handler (context, data) { ... } } } 复制代码组件中怎么提交modules中的moduleA中的mutationA？参考答案this.$store.commit('moduleA/mutationA',data) 复制代码怎么使用mapState，mapGetters，mapActions和mapMutations这些函数来绑定带命名空间的模块？参考答案首先使用createNamespacedHelpers创建基于某个命名空间辅助函数import { createNamespacedHelpers } from 'vuex'; const { mapState, mapActions } = createNamespacedHelpers('moduleA'); export default { computed: { // 在 `module/moduleA` 中查找 ...mapState({ a: state =&gt; state.a, b: state =&gt; state.b }) }, methods: { // 在 `module/moduleA` 中查找 ...mapActions([ 'actionA', 'actionB' ]) } } 复制代码Vuex插件有用过吗？怎么用简单介绍一下？参考答案Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入export default function createPlugin(param){ return store =&gt;{ //... } } 复制代码然后在store/index.js文件中写入import createPlugin from './plugin.js' const plugin = createPlugin() const store = new Vuex.Store({ // ... plugins: [myPlugin] }) 复制代码在Vuex插件中怎么监听组件中提交mutation和action？参考答案用Vuex.Store的实例方法subscribe监听组件中提交mutation用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入export default function createPlugin(param) { return store =&gt; { store.subscribe((mutation, state) =&gt; { console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) }) // store.subscribeAction((action, state) =&gt; { // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // }) store.subscribeAction({ before: (action, state) =&gt; {//提交action之前 console.log(`before action ${action.type}`) }, after: (action, state) =&gt; {//提交action之后 console.log(`after action ${action.type}`) } }) } } 复制代码然后在store/index.js文件中写入import createPlugin from './plugin.js' const plugin = createPlugin() const store = new Vuex.Store({ // ... plugins: [myPlugin] }) 复制代码在v-model上怎么用Vuex中state的值？参考答案需要通过computed计算属性来转换。&lt;input v-model="message"&gt; // ... computed: { message: { get () { return this.$store.state.message }, set (value) { this.$store.commit('updateMessage', value) } } } 复制代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue - Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟脚本与异步脚本]]></title>
    <url>%2F2019%2F11%2F15%2F%E5%BB%B6%E8%BF%9F%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[延迟脚本HTML4.01为&lt;script&gt;标签定义了defer属性作用：这个属性的用途是表明脚 本在执行时不会影响页面的构造运行时间：脚本会被延迟到整个页面都解析完毕后再运行，因此，在&lt;script&gt;元素中设置defer属性，相当于告诉浏览器会立即下载，但会延迟执行。123456789&lt;DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example2.js&quot;&gt;&lt;/script&gt; &lt;/title&gt; &lt;/head&gt;&lt;/html&gt;在这个例子中，虽然我们把&lt;script&gt;元素放在了文档的&lt;head&gt;元素中，但其中包含的脚本将延迟到浏览器遇到&lt;/html&gt;标签后再执行注意：最好之包含一个延迟脚本，因为两个延迟脚本在现实中并不一定会安装顺序执行，也不一定会在DOMContentLoaded时间触发前执行支持延迟的脚本的浏览器：IE Firefox Safari Chrome异步脚本HTML5为&lt;script&gt;元素定义了async属性。saync属性与``defer`属性的相同点：都只适用于外部脚本文件，并告诉浏览器立即下载文件。不同点：标记为async的脚本并不保证按照指定他们的先后顺序执行。列如：123456789&lt;DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example2.js&quot;&gt;&lt;/script&gt; &lt;/title&gt; &lt;/head&gt;&lt;/html&gt;注意：以上代码中，第二个脚本可能会在第一个脚本文件之前执行。因此，二者之间最好互不依赖指定async属性的目的是不让页面等待两个脚本下载执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM异步脚本一定会在页面load事件前执行，但可能会在DOMContentLoaded事件触发之前或者之后执行。支持异步的脚本的浏览器： Firefox Safari Chrome1在 XHTML 文档中，要把`async` 属性设置为 `async=&quot;async&quot;`]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js - 原生JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员实用工具网站]]></title>
    <url>%2F2019%2F11%2F12%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[转载自： https://blog.csdn.net/m0_38106923/article/details/100130354目录1、搜索引擎2、PPT3、图片操作4、文件共享5、应届生招聘6、程序员面试题库7、办公、开发软件8、高清图片、视频素材网站&nbsp;9、项目开源10、在线工具宝典大全程序员开发需要具备良好的信息检索能力，为了备忘（收藏夹真是满了），将开发过程中常用的网站进行整理。1、搜索引擎1.1、秘迹搜索一款无敌有良心、无敌安全的搜索引擎，不会收集私人信息，保护私隐，没有Cookie，并且秘迹搜索聚合了百度、360、Bing、搜狗等搜索结果。网站：https://mijisou.com1.2、小白盘度盘资源搜索的网站，能够搜索电影、电视剧、小说、音乐等资源（注意：评论区很多小伙伴说小白盘有毒，我用谷歌浏览器搜索过几次并无大碍，请慎用！）网站：https://www.xiaobaipan.com1.3、&nbsp;DogeDoge搜索DogeDoge搜索，中文名多吉搜索，一个绝赞的民间高手开发的搜索引擎，传说完全可以替代百度搜索，百度首页几乎都是广告，而 DogeDoge搜索一个广告都没有，搜索答案侧重于知乎、博客园、CSDN等，实在良心，搜索结果和谷歌差不多，非常适合那些无法科学上网的朋友。网站：https://www.dogedoge.com/1.4、GitLogsGitLogs 是GitHub网站的内容搜索引擎，可以帮助工程师们快速的找到相关的项目，同时也提供最新的开发项目、开发新闻、相关主题推荐等资源，支持邮箱订阅文章，每天都可以收到GitHub网站上的最新内容。网站：https://www.gitlogs.com/&nbsp;2、PPT2.1、优品PPT高品质免费PPT模板下载网站，比第一PPT质量高很多。网站：http://www.ypppt.com3、图片操作3.1、图片无限变大让你的图片无损放大，放大，再放大！只需要稍稍处理一下就可达到意想不到的效果。网站：http://bigjpg.com/zh3.2、waifu2x无损放大图片waifu2x 是一位来自日本的开发者所开源的项目，该项目利用人工智能深度卷积神经网络技术来无损放大图片，堪称是一款图片放大神器。一般图片在放大后可能会出现边界锯齿、线条模糊等问题，而 waifu2x 的算法对此提供了非常好的图片拉伸、降噪、填补机制，使得放大前后的图片给人观感基本一致。网站：http://waifu2x.udp.jp/index.zh-CN.html&nbsp; &nbsp; &nbsp; &nbsp;GitHub源码：https://github.com/nagadomi/waifu2x3.3、Remove Image Background照片抠图和证件照换底色由 byteq 开发人员 Benjamin Groessing 所开发的 remove.bg 是一款基于 Python、Ruby 和深度学习的抠图工具，它通过 AI 技术自动识别前景层，然后将之与背景层分离开来。网站目前免费开放，无论你是专业设计师还是刚入行的运营小白，都可以上传照片实现自动抠图，免去选择、标记等一系列繁琐的常规操作。真是照片抠图和证件照换底色的绝佳利器。网站：https://www.remove.bg/&nbsp; &nbsp; &nbsp;&nbsp;Python代码实现：https://handsome-man.blog.csdn.net/article/details/1020250593.4、TinyPNG免费的在线图片压缩工具，压缩率高，无损画质，直接拖拽使用，独特且强悍的JavaScript 算法，能极速压缩 80% 的图片大小，而不损害其质量。网站：https://tinypng.com/3.5、SmartResize基于 JavaScript+HTML5 编写的一个批量裁剪缩放图片神器（适合简单的人工智能图像数据预处理）。网站：https://www.smartresize.com/zh-cn&nbsp;4、文件共享4.1、拷贝兔拷贝兔是款跨平台文件传输工具，能做到不同设备间文件或文本的临时性迅速分享的应用，支持Windows、Mac、Linux、iOS、Android平台互传；在线使用，用完即走。比百度网盘方便多了。网站：https://cp.anyknew.com5、应届生招聘5.1、应届生求职网为大学生提供全方位的求职服务，提供最全、最新、最准确的校园宣讲、全职招聘、兼职实习、知名企业校园招聘、现场招聘会等信息，并且为大学生提供针对性的求职就业指导。网站：http://s.yingjiesheng.com/6、程序员面试题库6.1、LeetCode（力扣）力扣题库，提供海量技术面试资源。网站：https://leetcode-cn.com/7、办公、开发软件7.1、我爱分享网分享各种常用软件安装包（配套破解软件），安装教程和自学视频，让小伙伴即时获取最新的软件，软件无忧，理工科必备利器！网站：http://www.zhanshaoyi.com/rjxz.html8、高清图片、视频素材网站&nbsp;整理了一份实用性爆表的表格图像、视频、矢量……共35个网站，表中含有网站简介和素材类型，做PPT必备啊~表格下载链接：链接：https://pan.baidu.com/s/1jPpbkZiqgTJTwcVKh4pd4w&nbsp; 提取码：t19j&nbsp;9、项目开源9.1、GitHubGitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。（访问不稳定，经常需要翻墙）网站：https://github.com/&nbsp;9.2、开源中国开源中国成立于2008年8月，是目前国内最大的开源技术社区，拥有超过200万会员，形成了由开源软件库、代码分享、资讯、协作翻译、码云、众包、招聘等几大模块内容，为IT开发者提供了一个发现、使用、并交流开源技术的平台。网站：https://www.oschina.net/&nbsp;9.3、码云码云是 OSCHINA.NET 推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管。目前已有超过 350 万的开发者选择码云。网站：https://gitee.com/&nbsp;10、在线工具宝典大全10.1、爱资料工具爱资料在线工具，为开发运维提供全面的在线工具箱，目前已开发工具270款，包含开发工具、运维工具、常用工具、SEO站长工具等，是好用，方便的在线工具网站。网站：https://www.toolnb.com/&nbsp;10.2、菜鸟工具最大的特点是支持各种语言的在线编辑，可以在网页上运行代码。网站：https://c.runoob.com/&nbsp;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 - 分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人图床搭建]]></title>
    <url>%2F2019%2F10%2F04%2F%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[个人图床搭建这里我们选择Chevereto大家可以到官方的github上下载源码官方有四种安装方式这里选择第四种下载压缩包，通过宝塔上传到网站根目录/www/wwwroot/解压这里我们需要新建一个网站（这里推荐大家去创建一个二级域名）记得更改一下权限（不改权限的话，图床可能无法访问）我们新建一个网站，然后把目录指定一下创建后我们需要修改一下网站的伪静态具体源码如下：12345678910111213# Image not found replacementlocation ~* (jpe?g|png|gif) &#123;log_not_found off;error_page 404 /content/images/system/default/404.gif;&#125;# CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123;add_header Access-Control-Allow-Origin &quot;*&quot;;&#125;# Pretty URLslocation / &#123;try_files $uri $uri/ /index.php?$query_string;&#125;然后直接访问域名就可以看到界面了然后登陆进去会有英文界面，在网站域名后面输入settings就可以把全局设置为中文了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>图床 - 分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人网盘搭建]]></title>
    <url>%2F2019%2F10%2F03%2F%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[个人网盘搭建选择一款网盘nextcloud下载地址可道云下载地址cloudreve与阿里云OSS结合这里建议有阿里云主机的选择第三个下载宝塔服务器运维面板宝塔官网:选择对应的系统版本提示：要想进入宝塔面板还必须在云主机防火墙上面开放8888端口在软件商店安装好相应的运行环境在宝塔面板中点击文件进入/www/wwwroot把下载好的网盘压缩包放到这里面来解压然后点击进入宝塔网站模块，添加站点，设置好域名，网站目录，数据库等提示：数据库可以选择MySQL这里需要设置伪静态为thinkphp,有宝塔的可以直接设置最后点击或者输入域名进入安装界面设置好管理员账号密码还有数据库用户名和密码就好了设置阿里云OSS对象存储方式阿里云OSS对象存储可以提升上传下载速度,坏处就是要钱这里我们进入网盘的管理面板设置上传策略填好后我们还需要到OSS的基础设置里面添加跨域访问规则。点击新建，新建如下规则：最后设置好就OK啦]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>网盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到远端的GitHub上]]></title>
    <url>%2F2019%2F10%2F03%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%AB%AF%E7%9A%84GitHub%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[将本地文件部署到远端的GitHubgit安装 git：Windows安装：官网下载安装如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。配置全局用户名和全局邮箱：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;your Email&quot;注意:git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。初始化本地文件git init*瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。*查询文件状态git status生成ssh key公钥：ssh-keygen -t rsa -C &#39;your email&#39;在GitHub上创建仓库然后把ssh key公钥添加进去关联仓库1.到 github 仓库然后复制仓库地址2.执行指令：git remote add origin 远程仓库地址检查是否连接成功ssh -T git@github.com提交到所有文件到暂存区git add .提交所有文件到本地仓库git commit -m &quot;备注&quot;提交到主仓库后，再提交到gitHub服务器上git push -u origin master由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：git push origin master另外，这里有个坑需要注意一下，就是在创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/guyibang/TEST2.git的错。这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并一下：$ git pull --rebase origin master这时你再push就能成功了。流程图:总结**：其实只需要进行下面几步就能把本地项目上传到Github1、在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；2、把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；3、再通过git commit -m “注释内容”把项目提交到仓库；4、在Github上设置好SSH密钥后，新建一个远程仓库，通过git remote add origin 你的仓库地址将本地仓库和远程仓库进行关联；5、最后通过git push -u origin master把本地仓库的项目推送到远程仓库（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看上面）。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2019%2F08%2F29%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体加粗要加粗的文字分别用两个*号包起来斜体要倾斜的文字左右分别用一个*号包起来斜体加粗要倾斜的文字左右分别用一个*包起来删除线要加删除线的文字左右分别用两个~~号包起来示例：1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容这是引用的内容这是引用的内容这是引用的内容四、分割线三个或者三个以上的 - 或者 * 都可以。示例：1234-------********效果如下：可以看到，显示效果是一样的。五、图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加示例：1![哔哩哔哩](http://img.jiege123.art/images/2019/09/25/10.jpg &quot;哔哩哔哩&quot;)上传本地图片直接点击导航栏的图片标志，选择图片即可六、超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加示例：12[小明网](http://blog.jiege123.art)[小明图床](http://img.jiege123.art)效果如下：小明网小明图床注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替或者 Ctrl+鼠标左键 打开。1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;七、列表无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格效果如下：列表内容列表内容列表内容有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格1.列表内容2.列表内容3.列表内容列表嵌套上一级和下一级之间敲三个空格即可一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容一级无序列表内容1.二级有序列表内容2.二级有序列表内容3.二级有序列表内容1.一级有序列表内容二级无序列表内容二级无序列表内容二级无序列表内容2.一级有序列表内容二级有序列表内容二级有序列表内容二级有序列表内容八、表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略示例：12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果如下：姓名|技能|排行–|:–:|–:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行12345(```) 代码... 代码... 代码...(```)1注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。示例：单行代码1`create database hero;`代码块123456(```) function fun()&#123; echo &quot;我是一个函数&quot;; &#125; fun();(```)十、流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op​效果如下： ![流程图](http://img.jiege123.art/images/2019/10/02/33ab9d27a11da19ce33f802b7d3bfebe.png&quot;流程图&quot;)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick Start创建一个新文章1$ hexo new "My New Post"More info: Writing运行服务1$ hexo serverMore info: Server生成静态文件1$ hexo generate注意：hexo g会在本地生成静态文件并且打包成.deploy_git 这个文件夹就是以后要部署到远程服务器的文件夹可以看到里面有一个 .git 的文件夹，相当于隐式的 git init,不过这一步hexo g 已经帮我们完成了More info: Generating部署到远程站点1$ hexo deployMore info: Deployment安全删除目录1rm -rf .git/清除缓存1hexo clean]]></content>
  </entry>
</search>
